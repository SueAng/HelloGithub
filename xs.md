# 引论
用户与之交互的程序，基于文本的通常称为shell，基于图标的则称为图形用户界面（Graphical User Interface,GUI）
多数计算机有两种运行模式：内核态和用户态。操作系统运行在内核态，操作系统对所有的硬件有完全访问权，可以运行机器所能运行的所有指令。软件的其余部分运行在用户态下，只是用了机器指令中的一个子集。那些会影响机器的控制或者输入输出的指令，在用户态中的程序里是禁止的。
用户接口程序shell或者GUI处于用户态程序中的最低层次。
## 什么是操作系统
操作系统是运行在内核态的软件。
### 作为拓展机的操作系统
在机器语言一级上，多数计算机的体系结构（指令集、储存组织、I/O和总线结构）是原始的，编程困难。操作系统提供很多用于控制输入/输出设备的驱动（软件）来进行软硬件交互。但是这还是过于底层，因此，操作系统都提供使用硬盘的又一层抽象：文件。使用该抽象，程序能够创建、读写文件，而不用考虑硬件处理细节。
抽象是管理复杂性的关键，抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分。一部分是关于抽象的定义以及实现，另一部分是随时调用这些抽象解决问题。
### 作为资源管理者的操作系统
自顶向下的观点：把操作系统看做向应用程序提供基本抽象的概念。
自底向上的观点：操作系统用来管理一个复杂系统的各个部分。
现代操作系统允许同时在内存中运行多道程序。
操作系统的主要任务是记录哪个程序在使用什么资源，对程序请求进行分配，评估使用代价，并且为不同的用户和程序调节相互冲突的资源请求。
资源管理包括以下两种方式实现多路复用（共享）资源：时间复用以及空间复用
## 操作系统历史
### 真空管和穿孔卡片
### 晶体管和批处理系统
### 集成电路和多道程序设计
### 个人计算机
### 移动计算机
## 计算机硬件简介
操作系统与运行该系统的计算机硬件联系密切。操作系统拓展了计算机指令集并管理计算机的资源


# 2进程与线程
## 2.1进程
### 2.1.1进程模型
在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干个顺序进程（sequential process）,简称进程（process）.一个进程就是一个正在执行程序的实例，
### 2.1.2 进程的创建
4种主要事件会导致进程的创建：   
> + 系统初始化
> + 正在执行的程序执行了创建进程的系统调用
> + 用户请求创建一个新进程
> + 一个批处理作业的初始化  

启动操作系统时会创建若干的前台进程和后台进程。停留在后台处理诸如电子邮件、Web页面、新闻、打印之类活动的进程被称为守护进程（daemon）。  
在UNIX系统中，只有一个系统调用可以用来创建新进程：fork.
### 2.1.3进程的终止
通常由下列条件引起：
> + 正常退出
> + 出错退出
> + 严重错误
> + 被其他进程杀死   
### 2.1.4 进程的层次结构
在某些系统中，当进程创建了另一个进程后，父进程与子进程就以某种形式关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。
### 2.1.5进程的状态
每个进程是一个独立的实体，有自己的程序计数器和内部状态，但是，进程之间经常需要相互作用。一个进程的输出结果可以作为另一个进程的输入。
当一个进程不能继续运行时，它就会被阻塞，典型的例子就是它还在等待可以使用的输入。还有可能是操作系统调用了另一个进程占用了CPU。
进程的三种状态：
> + 运行态
> + 就绪态
> + 阻塞态（除非某种外部事件发生，否则进程不能运行）    
### 2.1.6进程的实现
为了实现进程模型，操作系统维护着一张表格，即进程表。每个进程占据一个进程表项，
## 2.2线程
### 2.2.1 线程的使用
 在许多应用中同时发生着很多活动，其中某些活动会随着时间的推移而被阻塞，通过将这些应用程序分为可以准并行运行的顺序线程，程序设计模型会变得更简单。

# 虚拟内存
## 页表
